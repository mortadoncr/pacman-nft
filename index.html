<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Pacman Simple</title>
<style>
  body, html {
    margin: 0; padding: 0; overflow: hidden; background: black;
    height: 100vh; display: flex; justify-content: center; align-items: center;
  }
  canvas {
    background: #111;
  }
</style>
</head>
<body>
<canvas id="canvas" width="440" height="360"></canvas>
<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

const tileSize = 40;

const map = [
  [1,1,1,1,1,1,1,1,1,1,1],
  [1,2,2,2,1,2,2,2,2,2,1],
  [1,2,1,2,1,2,1,1,2,2,1],
  [1,2,1,2,2,2,2,1,2,2,1],
  [1,2,1,1,1,1,2,1,1,2,1],
  [1,2,2,2,2,2,2,2,2,2,1],
  [1,2,1,1,1,1,1,1,1,2,1],
  [1,2,2,2,2,2,2,2,2,2,1],
  [1,1,1,1,1,1,1,1,1,1,1]
];

let player = {
  x: 1,
  y: 1,
  px: 1 * tileSize,
  py: 1 * tileSize,
  size: tileSize * 0.8,
  speed: 3,
  dir: null,
  nextDir: null
};

function canMoveTo(x, y) {
  if (y < 0 || y >= map.length || x < 0 || x >= map[0].length) return false;
  return map[y][x] !== 1;
}

function isAligned() {
  // Check if player is aligned with grid (center of tile on both axes)
  return (
    Math.abs(player.px % tileSize) < 2 &&
    Math.abs(player.py % tileSize) < 2
  );
}

function tryChangeDirection() {
  if (!player.nextDir) return;
  
  // For changing direction, player must be aligned on the axis perpendicular to movement
  if (player.nextDir === "left" || player.nextDir === "right") {
    if (Math.abs(player.py % tileSize) > 2) return;
  }
  if (player.nextDir === "up" || player.nextDir === "down") {
    if (Math.abs(player.px % tileSize) > 2) return;
  }
  
  // Calculate target tile if change direction possible
  let targetX = player.x;
  let targetY = player.y;
  if (player.nextDir === "left") targetX--;
  else if (player.nextDir === "right") targetX++;
  else if (player.nextDir === "up") targetY--;
  else if (player.nextDir === "down") targetY++;
  
  if (canMoveTo(targetX, targetY)) {
    player.dir = player.nextDir;
    player.nextDir = null;
  }
}

function update() {
  tryChangeDirection();
  if (!player.dir) return;
  
  let dx = 0, dy = 0;
  if (player.dir === "left") dx = -player.speed;
  else if (player.dir === "right") dx = player.speed;
  else if (player.dir === "up") dy = -player.speed;
  else if (player.dir === "down") dy = player.speed;
  
  // Compute new pixel positions
  let newPx = player.px + dx;
  let newPy = player.py + dy;
  
  // Compute next tile based on direction and position after move
  let nextTileX = Math.floor((newPx + player.size / 2) / tileSize);
  let nextTileY = Math.floor((newPy + player.size / 2) / tileSize);
  
  if (canMoveTo(nextTileX, nextTileY)) {
    player.px = newPx;
    player.py = newPy;
    player.x = nextTileX;
    player.y = nextTileY;
  } else {
    // Stop if hits wall
    player.dir = null;
  }
}

function drawMap() {
  for (let y = 0; y < map.length; y++) {
    for (let x = 0; x < map[y].length; x++) {
      if (map[y][x] === 1) {
        ctx.fillStyle = "#2222cc";
        ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
      } else if (map[y][x] === 2) {
        ctx.fillStyle = "#ff0";
        ctx.beginPath();
        ctx.arc(x * tileSize + tileSize/2, y * tileSize + tileSize/2, tileSize/8, 0, Math.PI*2);
        ctx.fill();
      } else {
        ctx.fillStyle = "#000";
        ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
      }
    }
  }
}

function drawPlayer() {
  ctx.fillStyle = "#ff0";
  ctx.beginPath();
  ctx.arc(player.px + player.size/2, player.py + player.size/2, player.size/2, 0, Math.PI*2);
  ctx.fill();
}

function gameLoop() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawMap();
  drawPlayer();
  update();
  requestAnimationFrame(gameLoop);
}

window.addEventListener("keydown", e => {
  if (e.key === "ArrowLeft") player.nextDir = "left";
  else if (e.key === "ArrowRight") player.nextDir = "right";
  else if (e.key === "ArrowUp") player.nextDir = "up";
  else if (e.key === "ArrowDown") player.nextDir = "down";
});

gameLoop();
</script>
</body>
</html>
