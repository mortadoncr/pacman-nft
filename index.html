<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pacman NFT</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: black;
      height: 100%;
    }
    canvas {
      display: block;
      margin: 0 auto;
      background: #111;
      width: 100vw;
      height: 100vh;
    }
    #mobile-controls {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 15px;
      z-index: 10;
    }
    #mobile-controls button {
      width: 60px;
      height: 60px;
      font-size: 24px;
      border-radius: 50%;
      border: none;
      background: #ff0;
      font-weight: bold;
      box-shadow: 0 4px 10px rgba(0,0,0,0.5);
    }
    #score {
      position: fixed;
      top: 10px;
      left: 10px;
      color: #ff0;
      font-family: monospace;
      font-size: 20px;
      z-index: 10;
    }
    #game-over {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: red;
      font-size: 48px;
      font-family: sans-serif;
      z-index: 10;
      display: none;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <div id="score">Score: 0</div>
  <div id="mobile-controls">
    <button onclick="move('up')">⬆️</button>
    <button onclick="move('left')">⬅️</button>
    <button onclick="move('down')">⬇️</button>
    <button onclick="move('right')">➡️</button>
  </div>
  <div id="game-over">GAME OVER</div>
  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener("resize", resize);
    resize();

    const tileSize = 40;

    const map = [...Array(11)].map(() => Array(21).fill(0)); // placeholder filled below
    const rawMap = [
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
      [1,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,1],
      [1,2,1,1,1,1,2,1,1,2,1,2,1,1,2,1,1,1,2,1,1],
      [1,2,1,2,2,1,2,2,2,2,2,2,2,2,2,1,2,2,2,2,1],
      [1,2,1,2,1,1,1,1,1,2,1,2,1,1,1,1,2,1,1,2,1],
      [1,2,2,2,1,2,2,2,1,2,1,2,1,2,2,2,2,1,2,2,1],
      [1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,1,1,1,2,1,1],
      [1,2,2,2,2,2,1,2,2,2,2,2,1,2,2,2,2,2,2,2,1],
      [1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1],
      [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
    ];
    for (let y = 0; y < rawMap.length; y++) {
      for (let x = 0; x < rawMap[y].length; x++) {
        map[y][x] = rawMap[y][x];
      }
    }

    const player = {
      x: 1,
      y: 1,
      size: tileSize * 0.8,
      px: 1 * tileSize,
      py: 1 * tileSize,
      image: new Image()
    };
    player.image.src = "pacman.png";

    const ghosts = [
      { x: 10, y: 5, px: 10 * tileSize, py: 5 * tileSize, color: "red", dx: 1, dy: 0 },
      { x: 15, y: 8, px: 15 * tileSize, py: 8 * tileSize, color: "pink", dx: -1, dy: 0 }
    ];

    let currentDirection = null;
    let nextDirection = null;
    let score = 0;
    let gameOver = false;

    function canMoveTo(x, y) {
      if (y < 0 || y >= map.length || x < 0 || x >= map[0].length) return false;
      return map[y][x] !== 1;
    }

    function tryChangeDirection() {
      if (!nextDirection) return;
      let nx = player.x;
      let ny = player.y;
      switch (nextDirection) {
        case "up": ny -= 1; break;
        case "down": ny += 1; break;
        case "left": nx -= 1; break;
        case "right": nx += 1; break;
      }
      if (canMoveTo(nx, ny)) {
        currentDirection = nextDirection;
        nextDirection = null;
      }
    }

    function updateGhosts() {
      ghosts.forEach(g => {
        let nextX = g.x + g.dx;
        let nextY = g.y + g.dy;
        if (!canMoveTo(nextX, nextY)) {
          const dirs = [
            { dx: 1, dy: 0 }, { dx: -1, dy: 0 },
            { dx: 0, dy: 1 }, { dx: 0, dy: -1 }
          ];
          const valid = dirs.filter(d => canMoveTo(g.x + d.dx, g.y + d.dy));
          const pick = valid[Math.floor(Math.random() * valid.length)];
          g.dx = pick.dx;
          g.dy = pick.dy;
        } else {
          g.x += g.dx;
          g.y += g.dy;
        }
        g.px = g.x * tileSize;
        g.py = g.y * tileSize;
      });
    }

    function checkCollision() {
      for (const g of ghosts) {
        if (Math.abs(player.px - g.px) < tileSize * 0.5 && Math.abs(player.py - g.py) < tileSize * 0.5) {
          document.getElementById("game-over").style.display = "block";
          gameOver = true;
        }
      }
    }

    function update() {
      if (gameOver) return;
      tryChangeDirection();

      if (!currentDirection) return;

      const speed = 4;
      let dx = 0, dy = 0;
      switch (currentDirection) {
        case "up": dy = -speed; break;
        case "down": dy = speed; break;
        case "left": dx = -speed; break;
        case "right": dx = speed; break;
      }

      let newPx = player.px + dx;
      let newPy = player.py + dy;

      let checkX = player.x;
      let checkY = player.y;

      if (currentDirection === "left") {
        checkX = Math.floor(newPx / tileSize);
      } else if (currentDirection === "right") {
        checkX = Math.floor((newPx + player.size) / tileSize);
      } else if (currentDirection === "up") {
        checkY = Math.floor(newPy / tileSize);
      } else if (currentDirection === "down") {
        checkY = Math.floor((newPy + player.size) / tileSize);
      }

      if (!canMoveTo(checkX, checkY)) return;

      player.px = newPx;
      player.py = newPy;
      player.x = Math.floor((player.px + player.size / 2) / tileSize);
      player.y = Math.floor((player.py + player.size / 2) / tileSize);

      if (map[player.y][player.x] === 2) {
        map[player.y][player.x] = 0;
        score++;
        document.getElementById("score").textContent = "Score: " + score;
      }

      updateGhosts();
      checkCollision();
    }

    function drawMap() {
      for (let y = 0; y < map.length; y++) {
        for (let x = 0; x < map[y].length; x++) {
          switch (map[y][x]) {
            case 1:
              ctx.fillStyle = "#2222cc";
              ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
              break;
            case 2:
              ctx.fillStyle = "#ff0";
              ctx.beginPath();
              ctx.arc(x * tileSize + tileSize / 2, y * tileSize + tileSize / 2, tileSize / 8, 0, 2 * Math.PI);
              ctx.fill();
              break;
            default:
              ctx.fillStyle = "#000";
              ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
              break;
          }
        }
      }
    }

    function drawPlayer() {
      ctx.drawImage(player.image, player.px, player.py, player.size, player.size);
    }

    function drawGhosts() {
      ghosts.forEach(g => {
        ctx.fillStyle = g.color;
        ctx.beginPath();
        ctx.arc(g.px + tileSize / 2, g.py + tileSize / 2, tileSize / 2.5, 0, 2 * Math.PI);
        ctx.fill();
      });
    }

    function loop() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      update();
      drawMap();
      drawPlayer();
      drawGhosts();
      requestAnimationFrame(loop);
    }

    loop();

    document.addEventListener("keydown", (e) => {
      switch (e.key) {
        case "ArrowUp": nextDirection = "up"; break;
        case "ArrowDown": nextDirection = "down"; break;
        case "ArrowLeft": nextDirection = "left"; break;
        case "ArrowRight": nextDirection = "right"; break;
      }
    });

    function move(dir) {
      nextDirection = dir;
    }
  </script>
</body>
</html>
