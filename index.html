<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Pacman NFT Jouable - Collision am√©lior√©e</title>
<style>
  html, body {
    margin: 0; padding: 0; overflow: hidden; background: black; height: 100%;
  }
  canvas {
    display: block;
    margin: 0 auto;
    background: #111;
    width: 100vw;
    height: 100vh;
  }
  #mobile-controls {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 15px;
    z-index: 10;
  }
  #mobile-controls button {
    width: 60px; height: 60px;
    font-size: 24px;
    border-radius: 50%;
    border: none;
    background: #ff0;
    font-weight: bold;
    box-shadow: 0 4px 10px rgba(0,0,0,0.5);
  }
  #score {
    position: fixed;
    top: 10px;
    left: 10px;
    color: #ff0;
    font-family: monospace;
    font-size: 20px;
    z-index: 10;
  }
</style>
</head>
<body>

<canvas id="gameCanvas"></canvas>

<div id="score">Score: 0</div>

<div id="mobile-controls">
  <button onclick="move('up')">‚¨ÜÔ∏è</button>
  <button onclick="move('left')">‚¨ÖÔ∏è</button>
  <button onclick="move('down')">‚¨áÔ∏è</button>
  <button onclick="move('right')">‚û°Ô∏è</button>
</div>

<script>
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");

  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  window.addEventListener("resize", resize);
  resize();

  const tileSize = 40;

  const map = [
    [1,1,1,1,1,1,1,1,1,1,1,1],
    [1,2,2,2,1,2,2,2,2,2,2,1],
    [1,2,1,2,1,2,1,1,1,1,2,1],
    [1,2,1,2,2,2,2,2,2,1,2,1],
    [1,2,1,1,1,1,1,1,2,1,2,1],
    [1,2,2,2,2,2,2,1,2,1,2,1],
    [1,1,1,1,1,1,2,1,2,1,2,1],
    [1,2,2,2,2,2,2,1,2,2,2,1],
    [1,2,1,1,1,1,1,1,1,1,2,1],
    [1,2,2,2,2,2,2,2,2,2,2,1],
    [1,1,1,1,1,1,1,1,1,1,1,1],
  ];

  const player = {
    x: 1,
    y: 1,
    size: tileSize*0.8,
    px: 1 * tileSize,
    py: 1 * tileSize,
    image: new Image()
  };
  player.image.src = "pacman.png";

  let score = 0;
  const maxScore = map.flat().filter(x=>x===2).length;

  let currentDirection = null;
  let nextDirection = null;

  function canMoveTo(x, y) {
    if (y < 0 || y >= map.length || x < 0 || x >= map[0].length) return false;
    return map[y][x] !== 1;
  }

  function tryChangeDirection() {
    if (!nextDirection) return false;
    let nx = player.x;
    let ny = player.y;

    switch (nextDirection) {
      case "up": ny -= 1; break;
      case "down": ny += 1; break;
      case "left": nx -= 1; break;
      case "right": nx += 1; break;
    }
    if (canMoveTo(nx, ny)) {
      currentDirection = nextDirection;
      nextDirection = null;
      return true;
    }
    return false;
  }

  function update() {
    if (!currentDirection) return;

    tryChangeDirection();

    const speed = 4;

    let dx = 0, dy = 0;
    switch (currentDirection) {
      case "up": dy = -speed; break;
      case "down": dy = speed; break;
      case "left": dx = -speed; break;
      case "right": dx = speed; break;
    }

    // Calcul position projet√©e
    let newPx = player.px + dx;
    let newPy = player.py + dy;

    // Calcul bord du joueur selon direction
    // On veut v√©rifier la prochaine case o√π le bord sera
    let checkX = player.x;
    let checkY = player.y;

    // Ajuste selon la direction, on check la case suivante c√¥t√© bord joueur
    if (currentDirection === "left") {
      checkX = Math.floor((newPx) / tileSize);
      checkY = player.y;
    } else if (currentDirection === "right") {
      checkX = Math.floor((newPx + player.size) / tileSize);
      checkY = player.y;
    } else if (currentDirection === "up") {
      checkX = player.x;
      checkY = Math.floor((newPy) / tileSize);
    } else if (currentDirection === "down") {
      checkX = player.x;
      checkY = Math.floor((newPy + player.size) / tileSize);
    }

    if (!canMoveTo(checkX, checkY)) {
      // Bloque Pacman juste avant le mur (sans rentrer dedans)
      switch (currentDirection) {
        case "left":
          newPx = (player.x) * tileSize;
          break;
        case "right":
          newPx = (player.x + 1) * tileSize - player.size;
          break;
        case "up":
          newPy = (player.y) * tileSize;
          break;
        case "down":
          newPy = (player.y + 1) * tileSize - player.size;
          break;
      }
      currentDirection = null; // stoppe le mouvement
    } else {
      player.px = newPx;
      player.py = newPy;

      // Mise √† jour des coordonn√©es case √† partir du centre du joueur
      player.x = Math.floor((player.px + player.size / 2) / tileSize);
      player.y = Math.floor((player.py + player.size / 2) / tileSize);

      // Ramasse les points
      if (map[player.y][player.x] === 2) {
        map[player.y][player.x] = 0;
        score++;
        document.getElementById("score").textContent = "Score: " + score;
        if (score === maxScore) {
          alert("You won! üéâ Refresh to play again.");
        }
      }
    }
  }

  function drawMap() {
    for (let y = 0; y < map.length; y++) {
      for (let x = 0; x < map[y].length; x++) {
        switch (map[y][x]) {
          case 1:
            ctx.fillStyle = "#2222cc";
            ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
            break;
          case 2:
            ctx.fillStyle = "#ff0";
            ctx.beginPath();
            ctx.arc(
              x * tileSize + tileSize / 2,
              y * tileSize + tileSize / 2,
              tileSize / 8,
              0,
              2 * Math.PI
            );
            ctx.fill();
            break;
          default:
            ctx.fillStyle = "#000";
            ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
        }
      }
    }
  }

  function drawPlayer() {
    ctx.drawImage(player.image, player.px, player.py, player.size, player.size);
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawMap();
    drawPlayer();
  }

  function gameLoop() {
    update();
    draw();
    requestAnimationFrame(gameLoop);
  }

  gameLoop();

  function move(dir) {
    nextDirection = dir;
    if (!currentDirection) {
      currentDirection = nextDirection;
      nextDirection = null;
    }
  }
  window.move = move;

  window.addEventListener("keydown", (e) => {
    switch (e.key) {
      case "ArrowUp":
        move("up");
        break;
      case "ArrowDown":
        move("down");
        break;
      case "ArrowLeft":
        move("left");
        break;
      case "ArrowRight":
        move("right");
        break;
    }
  });
</script>

</body>
</html>
