<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Pacman NFT</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: black;
      height: 100%;
      overflow: hidden;
    }
    canvas {
      display: block;
      margin: 0 auto;
      background: #111;
    }
    #mobile-controls {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 15px;
      z-index: 10;
    }
    #mobile-controls button {
      width: 60px;
      height: 60px;
      font-size: 24px;
      border-radius: 50%;
      border: none;
      background: #ff0;
      font-weight: bold;
      box-shadow: 0 4px 10px rgba(0,0,0,0.5);
    }
    #score {
      position: fixed;
      top: 10px;
      left: 10px;
      color: #ff0;
      font-family: monospace;
      font-size: 20px;
      z-index: 10;
    }
    #end-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.8);
      color: #ff0;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      font-family: monospace;
      font-size: 30px;
      z-index: 20;
      display: none;
    }
    #end-screen button {
      margin-top: 20px;
      padding: 10px 20px;
      font-size: 20px;
      background: #ff0;
      border: none;
      border-radius: 10px;
      font-weight: bold;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <div id="score">Score: 0</div>
  <div id="mobile-controls">
    <button onclick="move('up')">‚¨ÜÔ∏è</button>
    <button onclick="move('left')">‚¨ÖÔ∏è</button>
    <button onclick="move('down')">‚¨áÔ∏è</button>
    <button onclick="move('right')">‚û°Ô∏è</button>
  </div>
  <div id="end-screen">
    <div>üéâ Bravo ! Vous avez tout mang√© !</div>
    <button onclick="restartGame()">Rejouer</button>
  </div>
  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener("resize", resize);
    resize();

    const tileSize = 40;

    const originalMap = [
      [1,1,1,1,1,1,1,1,1,1,1],
      [1,2,2,2,1,2,2,2,2,2,1],
      [1,2,1,2,1,2,1,1,2,2,1],
      [1,2,1,2,2,2,2,1,2,2,1],
      [1,2,1,1,1,1,2,1,1,2,1],
      [1,2,2,2,2,2,2,2,2,2,1],
      [1,2,1,1,1,1,1,1,1,2,1],
      [1,2,2,2,2,2,2,2,2,2,1],
      [1,1,1,1,1,1,1,1,1,1,1]
    ];

    let map = JSON.parse(JSON.stringify(originalMap));

    const player = {
      x: 1,
      y: 1,
      size: tileSize * 0.8,
      px: tileSize,
      py: tileSize,
      image: new Image()
    };
    player.image.src = "pacman.png";

    let currentDirection = null;
    let nextDirection = null;
    let score = 0;

    const ghosts = [
      { x: 5, y: 5, px: 5 * tileSize, py: 5 * tileSize, dir: "left", color: "red" },
      { x: 9, y: 1, px: 9 * tileSize, py: 1 * tileSize, dir: "up", color: "cyan" }
    ];

    function canMoveTo(x, y) {
      return map[y] && map[y][x] !== 1;
    }

    function tryChangeDirection() {
      if (!nextDirection) return;

      const centerX = player.px + player.size / 2;
      const centerY = player.py + player.size / 2;
      const alignedX = Math.abs(centerX % tileSize - tileSize / 2) < 2;
      const alignedY = Math.abs(centerY % tileSize - tileSize / 2) < 2;

      let nx = player.x;
      let ny = player.y;

      switch (nextDirection) {
        case "up": ny -= 1; break;
        case "down": ny += 1; break;
        case "left": nx -= 1; break;
        case "right": nx += 1; break;
      }

      if ((nextDirection === "left" || nextDirection === "right") && alignedY && canMoveTo(nx, ny)) {
        currentDirection = nextDirection;
        nextDirection = null;
        player.py = Math.round(player.py / tileSize) * tileSize;
      }
      if ((nextDirection === "up" || nextDirection === "down") && alignedX && canMoveTo(nx, ny)) {
        currentDirection = nextDirection;
        nextDirection = null;
        player.px = Math.round(player.px / tileSize) * tileSize;
      }
    }

    function update() {
      tryChangeDirection();
      if (!currentDirection) return;

      const speed = 2;
      let dx = 0, dy = 0;

      switch (currentDirection) {
        case "up": dy = -speed; break;
        case "down": dy = speed; break;
        case "left": dx = -speed; break;
        case "right": dx = speed; break;
      }

      const newPx = player.px + dx;
      const newPy = player.py + dy;
      const newX = Math.floor((newPx + player.size / 2) / tileSize);
      const newY = Math.floor((newPy + player.size / 2) / tileSize);

      if (canMoveTo(newX, newY)) {
        player.px = newPx;
        player.py = newPy;
        player.x = newX;
        player.y = newY;

        if (map[player.y][player.x] === 2) {
          map[player.y][player.x] = 0;
          score++;
          document.getElementById("score").textContent = "Score: " + score;
          checkWin();
        }
      }
    }

    function updateGhosts() {
      ghosts.forEach(g => {
        const dirs = ["up", "down", "left", "right"];
        const speed = 1;
        let dx = 0, dy = 0;

        switch (g.dir) {
          case "up": dy = -speed; break;
          case "down": dy = speed; break;
          case "left": dx = -speed; break;
          case "right": dx = speed; break;
        }

        const nextX = Math.floor((g.px + dx + tileSize / 2) / tileSize);
        const nextY = Math.floor((g.py + dy + tileSize / 2) / tileSize);

        if (canMoveTo(nextX, nextY)) {
          g.px += dx;
          g.py += dy;
          g.x = nextX;
          g.y = nextY;
        } else {
          g.dir = dirs[Math.floor(Math.random() * 4)];
        }
      });
    }

    function drawMap() {
      for (let y = 0; y < map.length; y++) {
        for (let x = 0; x < map[y].length; x++) {
          switch (map[y][x]) {
            case 1:
              ctx.fillStyle = "#2222cc";
              ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
              break;
            case 2:
              ctx.fillStyle = "#ff0";
              ctx.beginPath();
              ctx.arc(x * tileSize + tileSize / 2, y * tileSize + tileSize / 2, tileSize / 8, 0, 2 * Math.PI);
              ctx.fill();
              break;
            default:
              ctx.fillStyle = "#000";
              ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
              break;
          }
        }
      }
    }

    function drawPlayer() {
      ctx.drawImage(player.image, player.px, player.py, player.size, player.size);
    }

    function drawGhosts() {
      ghosts.forEach(g => {
        ctx.fillStyle = g.color;
        ctx.beginPath();
        ctx.arc(g.px + tileSize / 2, g.py + tileSize / 2, tileSize / 2.5, 0, 2 * Math.PI);
        ctx.fill();
      });
    }

    function checkWin() {
      for (let y = 0; y < map.length; y++) {
        for (let x = 0; x < map[y].length; x++) {
          if (map[y][x] === 2) return;
        }
      }
      setTimeout(() => {
        document.getElementById("end-screen").style.display = "flex";
      }, 300);
    }

    function restartGame() {
      map = JSON.parse(JSON.stringify(originalMap));
      score = 0;
      currentDirection = null;
      nextDirection = null;
      player.px = tileSize;
      player.py = tileSize;
      player.x = 1;
      player.y = 1;
      document.getElementById("score").textContent = "Score: 0";
      document.getElementById("end-screen").style.display = "none";
    }

    function loop() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      update();
      updateGhosts();
      drawMap();
      drawGhosts();
      drawPlayer();
      requestAnimationFrame(loop);
    }

    player.image.onload = () => loop();

    document.addEventListener("keydown", (e) => {
      switch (e.key) {
        case "ArrowUp": nextDirection = "up"; break;
        case "ArrowDown": nextDirection = "down"; break;
        case "ArrowLeft": nextDirection = "left"; break;
        case "ArrowRight": nextDirection = "right"; break;
      }
    });

    function move(dir) {
      nextDirection = dir;
    }
  </script>
</body>
</html>
