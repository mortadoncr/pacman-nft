<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Pacman Simple</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: black;
      overflow: hidden;
    }
    canvas {
      display: block;
      margin: auto;
      background: #111;
    }
  </style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
canvas.width = 440;
canvas.height = 360;

const tileSize = 40;
const map = [
  [1,1,1,1,1,1,1,1,1,1,1],
  [1,2,2,2,1,2,2,2,2,2,1],
  [1,2,1,2,1,2,1,1,2,2,1],
  [1,2,1,2,2,2,2,1,2,2,1],
  [1,2,1,1,1,1,2,1,1,2,1],
  [1,2,2,2,2,2,2,2,2,2,1],
  [1,2,1,1,1,1,1,1,1,2,1],
  [1,2,2,2,2,2,2,2,2,2,1],
  [1,1,1,1,1,1,1,1,1,1,1]
];

const player = {
  x: 1,
  y: 1,
  px: 1 * tileSize,
  py: 1 * tileSize,
  size: tileSize * 0.8,
  speed: 2,
  currentDirection: null,
  nextDirection: null
};

function canMoveTo(x, y) {
  return map[y] && map[y][x] !== 1;
}

function tryChangeDirection() {
  if (!player.nextDirection) return;

  let nx = player.x;
  let ny = player.y;

  switch(player.nextDirection) {
    case "left": nx--; break;
    case "right": nx++; break;
    case "up": ny--; break;
    case "down": ny++; break;
  }

  if (canMoveTo(nx, ny)) {
    player.currentDirection = player.nextDirection;
    player.nextDirection = null;
  }
}

function updatePosition(){
  if (!player.currentDirection) return;

  let dx = 0, dy = 0;
  switch (player.currentDirection) {
    case "left": dx = -player.speed; break;
    case "right": dx = player.speed; break;
    case "up": dy = -player.speed; break;
    case "down": dy = player.speed; break;
  }

  const nextPx = player.px + dx;
  const nextPy = player.py + dy;

  const nextCenterX = nextPx + player.size / 2;
  const nextCenterY = nextPy + player.size / 2;

  const nextTileX = Math.floor(nextCenterX / tileSize);
  const nextTileY = Math.floor(nextCenterY / tileSize);

  if (canMoveTo(nextTileX, nextTileY)) {
    player.px = nextPx;
    player.py = nextPy;
    player.x = Math.floor((player.px + player.size/2) / tileSize);
    player.y = Math.floor((player.py + player.size/2) / tileSize);
  } else {
    player.px = player.x * tileSize;
    player.py = player.y * tileSize;
    player.currentDirection = null;
  }
}

function update() {
  tryChangeDirection();
  updatePosition();
  if (map[player.y][player.x] === 2) {
    map[player.y][player.x] = 0;
  }
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Draw map
  for (let y = 0; y < map.length; y++) {
    for (let x = 0; x < map[y].length; x++) {
      if (map[y][x] === 1) {
        ctx.fillStyle = "#2222cc";
        ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
      } else if (map[y][x] === 2) {
        ctx.fillStyle = "#ff0";
        ctx.beginPath();
        ctx.arc(x * tileSize + tileSize/2, y * tileSize + tileSize/2, 5, 0, Math.PI * 2);
        ctx.fill();
      }
    }
  }

  // Draw player
  ctx.fillStyle = "yellow";
  ctx.beginPath();
  ctx.arc(player.px + player.size / 2, player.py + player.size / 2, player.size / 2, 0.25 * Math.PI, 1.75 * Math.PI);
  ctx.lineTo(player.px + player.size / 2, player.py + player.size / 2);
  ctx.fill();
}

function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}

loop();

// Controls
window.addEventListener("keydown", e => {
  switch(e.key) {
    case "ArrowLeft": player.nextDirection = "left"; break;
    case "ArrowRight": player.nextDirection = "right"; break;
    case "ArrowUp": player.nextDirection = "up"; break;
    case "ArrowDown": player.nextDirection = "down"; break;
  }
});
</script>
</body>
</html>
